import axios from 'axios';
import chalk from 'chalk';
import { services } from './services.js';
import { callServices } from './call-services.js';

const TEST_PHONE = '+380000000000';

async function analyzeService(service) {
  const result = {
    name: service.name,
    category: service.category,
    vulnerabilities: [],
    protections: [],
    riskLevel: 'unknown'
  };

  const url = service.url.replace(/{phone}/g, TEST_PHONE);
  let data = JSON.parse(JSON.stringify(service.data));
  
  const replacePhone = (obj) => {
    if (typeof obj === 'string') return obj.replace(/{phone}/g, TEST_PHONE);
    if (Array.isArray(obj)) return obj.map(replacePhone);
    if (typeof obj === 'object' && obj !== null) {
      const r = {};
      for (const [k, v] of Object.entries(obj)) r[k] = replacePhone(v);
      return r;
    }
    return obj;
  };
  
  data = replacePhone(data);

  try {
    const response = await axios({
      method: service.method.toLowerCase(),
      url: url,
      data: data,
      headers: service.headers,
      timeout: 10000,
      validateStatus: () => true
    });

    const status = response.status;
    const body = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);

    if (status === 200 || status === 201) {
      result.vulnerabilities.push('No rate limiting detected');
      result.vulnerabilities.push('Accepts requests without CAPTCHA');
      result.riskLevel = 'high';
    } else if (status === 429) {
      result.protections.push('Rate limiting active');
      result.riskLevel = 'low';
    } else if (status === 403) {
      if (body.includes('captcha') || body.includes('recaptcha')) {
        result.protections.push('CAPTCHA protection');
        result.riskLevel = 'low';
      } else {
        result.protections.push('Access forbidden (may have IP blocking)');
        result.riskLevel = 'medium';
      }
    } else if (status === 400) {
      if (body.includes('invalid') || body.includes('validation')) {
        result.protections.push('Input validation');
        result.riskLevel = 'medium';
      }
    } else if (status === 401 || status === 403) {
      result.protections.push('Authentication required');
      result.riskLevel = 'low';
    }

    const headers = response.headers;
    if (headers['x-ratelimit-limit'] || headers['ratelimit-limit']) {
      result.protections.push(`Rate limit header present`);
    }
    if (headers['x-request-id'] || headers['cf-ray']) {
      result.protections.push('Request tracking enabled');
    }

    result.statusCode = status;
    result.responseSnippet = body.substring(0, 200);

  } catch (error) {
    if (error.code === 'ECONNREFUSED') {
      result.protections.push('Service unavailable or blocked');
      result.riskLevel = 'low';
    } else if (error.code === 'ETIMEDOUT') {
      result.vulnerabilities.push('Slow response (may be processing)');
      result.riskLevel = 'medium';
    } else {
      result.error = error.message;
      result.riskLevel = 'unknown';
    }
  }

  if (result.vulnerabilities.length === 0 && result.protections.length === 0) {
    result.riskLevel = 'unknown';
  }

  return result;
}

async function main() {
  console.log(chalk.cyan('\n╔════════════════════════════════════════════════════════════════╗'));
  console.log(chalk.cyan('║') + chalk.yellow.bold('        VULNERABILITY ANALYZER FOR OTP ENDPOINTS                ') + chalk.cyan('║'));
  console.log(chalk.cyan('║') + chalk.gray('        Identifies unprotected API endpoints                    ') + chalk.cyan('║'));
  console.log(chalk.cyan('╚════════════════════════════════════════════════════════════════╝\n'));

  console.log(chalk.yellow('⚠ This analyzer tests endpoints with a fake phone number'));
  console.log(chalk.yellow('  to identify which services are vulnerable to SMS bombing.\n'));

  const allServices = [...services, ...callServices];
  const results = [];

  console.log(chalk.white(`Analyzing ${allServices.length} services...\n`));

  for (const service of allServices.slice(0, 10)) {
    process.stdout.write(chalk.gray(`Testing ${service.name}... `));
    const result = await analyzeService(service);
    results.push(result);

    const riskColor = result.riskLevel === 'high' ? chalk.red :
                     result.riskLevel === 'medium' ? chalk.yellow :
                     result.riskLevel === 'low' ? chalk.green : chalk.gray;
    
    console.log(riskColor(`[${result.riskLevel.toUpperCase()}]`));

    await new Promise(r => setTimeout(r, 1000));
  }

  console.log(chalk.cyan('\n─── ANALYSIS RESULTS ──────────────────────────────────────────\n'));

  const highRisk = results.filter(r => r.riskLevel === 'high');
  const mediumRisk = results.filter(r => r.riskLevel === 'medium');
  const lowRisk = results.filter(r => r.riskLevel === 'low');

  console.log(chalk.red(`HIGH RISK (${highRisk.length}):`));
  for (const r of highRisk) {
    console.log(chalk.red(`  • ${r.name}`));
    for (const v of r.vulnerabilities) {
      console.log(chalk.gray(`    - ${v}`));
    }
  }

  console.log(chalk.yellow(`\nMEDIUM RISK (${mediumRisk.length}):`));
  for (const r of mediumRisk) {
    console.log(chalk.yellow(`  • ${r.name}`));
  }

  console.log(chalk.green(`\nLOW RISK (${lowRisk.length}):`));
  for (const r of lowRisk) {
    console.log(chalk.green(`  • ${r.name}`));
    for (const p of r.protections) {
      console.log(chalk.gray(`    + ${p}`));
    }
  }

  console.log(chalk.cyan('\n─── RECOMMENDATIONS ───────────────────────────────────────────\n'));
  console.log(chalk.white('For high-risk services, consider:'));
  console.log(chalk.gray('  1. Implementing rate limiting (e.g., 3 OTPs per phone per hour)'));
  console.log(chalk.gray('  2. Adding CAPTCHA verification'));
  console.log(chalk.gray('  3. Phone number reputation checking'));
  console.log(chalk.gray('  4. Requiring authenticated sessions'));
  console.log(chalk.gray('  5. Monitoring for suspicious request patterns'));

  console.log('');
}

main().catch(console.error);
